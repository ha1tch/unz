// Command mkdict trains a BPE vocabulary from input text.
//
// Usage:
//
//	mkdict [-n merges] [-o output] [input...]
//
// If no input files are specified, reads from stdin.
// Output is Go source code that can be embedded in the vocab package.
package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"os"
	"sort"
	"strings"
)

var (
	numMerges  = flag.Int("n", 1000, "number of BPE merges to perform")
	outputFile = flag.String("o", "", "output file (default: stdout)")
	goPackage  = flag.String("pkg", "vocab", "Go package name for output")
	varName    = flag.String("var", "defaultTokens", "variable name for token map")
	help       = flag.Bool("h", false, "display help")
)

func main() {
	flag.Usage = usage
	flag.Parse()

	if *help {
		usage()
		os.Exit(0)
	}

	// Read input
	var input []byte
	var err error

	if flag.NArg() == 0 {
		input, err = io.ReadAll(os.Stdin)
	} else {
		for _, filename := range flag.Args() {
			data, err := os.ReadFile(filename)
			if err != nil {
				fatal("cannot read '%s': %v", filename, err)
			}
			input = append(input, data...)
		}
	}
	if err != nil {
		fatal("cannot read input: %v", err)
	}

	if len(input) == 0 {
		fatal("no input data")
	}

	fmt.Fprintf(os.Stderr, "Training on %d bytes, %d merges...\n", len(input), *numMerges)

	// Train vocabulary
	tokenRanks := trainBPE(input, *numMerges)

	fmt.Fprintf(os.Stderr, "Generated %d tokens\n", len(tokenRanks))

	// Generate output
	var out io.Writer = os.Stdout
	if *outputFile != "" {
		f, err := os.Create(*outputFile)
		if err != nil {
			fatal("cannot create output: %v", err)
		}
		defer f.Close()
		out = f
	}

	writeGoSource(out, tokenRanks)
}

func trainBPE(text []byte, numMerges int) map[string]int {
	// Start with byte-level tokens
	tokenRanks := make(map[string]int)
	for i := 0; i < 256; i++ {
		tokenRanks[string([]byte{byte(i)})] = i
	}

	// Convert text to token IDs
	ids := make([]int, len(text))
	for i, b := range text {
		ids[i] = int(b)
	}

	// Track token bytes by ID
	idToBytes := make(map[int][]byte)
	for i := 0; i < 256; i++ {
		idToBytes[i] = []byte{byte(i)}
	}

	nextRank := 256

	for merge := 0; merge < numMerges; merge++ {
		if len(ids) < 2 {
			break
		}

		// Count pairs
		pairCounts := make(map[[2]int]int)
		for i := 0; i < len(ids)-1; i++ {
			pair := [2]int{ids[i], ids[i+1]}
			pairCounts[pair]++
		}

		if len(pairCounts) == 0 {
			break
		}

		// Find most frequent pair
		var bestPair [2]int
		bestCount := 0
		for pair, count := range pairCounts {
			if count > bestCount {
				bestCount = count
				bestPair = pair
			}
		}

		if bestCount < 2 {
			break
		}

		// Create new token
		newBytes := append([]byte{}, idToBytes[bestPair[0]]...)
		newBytes = append(newBytes, idToBytes[bestPair[1]]...)

		tokenRanks[string(newBytes)] = nextRank
		idToBytes[nextRank] = newBytes
		newID := nextRank
		nextRank++

		// Merge in sequence
		newIDs := make([]int, 0, len(ids))
		i := 0
		for i < len(ids) {
			if i < len(ids)-1 && ids[i] == bestPair[0] && ids[i+1] == bestPair[1] {
				newIDs = append(newIDs, newID)
				i += 2
			} else {
				newIDs = append(newIDs, ids[i])
				i++
			}
		}
		ids = newIDs

		if (merge+1)%100 == 0 {
			fmt.Fprintf(os.Stderr, "  %d merges, %d tokens\n", merge+1, nextRank)
		}
	}

	return tokenRanks
}

func writeGoSource(w io.Writer, tokenRanks map[string]int) {
	bw := bufio.NewWriter(w)
	defer bw.Flush()

	// Sort by rank
	type kv struct {
		token string
		rank  int
	}
	sorted := make([]kv, 0, len(tokenRanks))
	for t, r := range tokenRanks {
		sorted = append(sorted, kv{t, r})
	}
	sort.Slice(sorted, func(i, j int) bool {
		return sorted[i].rank < sorted[j].rank
	})

	fmt.Fprintf(bw, "// Code generated by mkdict. DO NOT EDIT.\n\n")
	fmt.Fprintf(bw, "package %s\n\n", *goPackage)
	fmt.Fprintf(bw, "// %s contains the pre-trained BPE vocabulary.\n", *varName)
	fmt.Fprintf(bw, "// Generated with %d merges from training corpus.\n", *numMerges)
	fmt.Fprintf(bw, "var %s = map[string]int{\n", *varName)

	for _, item := range sorted {
		fmt.Fprintf(bw, "\t%s: %d,\n", goStringLiteral(item.token), item.rank)
	}

	fmt.Fprintf(bw, "}\n")
}

func goStringLiteral(s string) string {
	var b strings.Builder
	b.WriteByte('"')
	for i := 0; i < len(s); i++ {
		c := s[i]
		switch {
		case c == '\\':
			b.WriteString(`\\`)
		case c == '"':
			b.WriteString(`\"`)
		case c == '\n':
			b.WriteString(`\n`)
		case c == '\r':
			b.WriteString(`\r`)
		case c == '\t':
			b.WriteString(`\t`)
		case c >= 0x20 && c <= 0x7e:
			b.WriteByte(c)
		default:
			fmt.Fprintf(&b, `\x%02x`, c)
		}
	}
	b.WriteByte('"')
	return b.String()
}

func usage() {
	fmt.Fprintf(os.Stderr, `Usage: mkdict [-n merges] [-o output] [input...]

Train a BPE vocabulary from input text and generate Go source code.

Options:
  -n N       number of BPE merges (default: 1000)
  -o file    output file (default: stdout)
  -pkg name  Go package name (default: vocab)
  -var name  variable name for token map (default: defaultTokens)
  -h         display this help

Examples:
  mkdict -n 2000 corpus.txt > vocab/tokens.go
  cat *.txt | mkdict -n 1500 -o vocab/tokens.go
  mkdict -n 1000 -pkg myvocab -var Tokens data/*.txt

`)
}

func fatal(format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, "mkdict: "+format+"\n", args...)
	os.Exit(1)
}
